* [[http://www.seas.upenn.edu/~cis194/spring13/][cis194 Brent Yorgey]]

* [[http://www.seas.upenn.edu/~cis194/fall14/][cis194 Richard Eisenberg]]
* [[https://github.com/goldfirere][Richard Eisenberg's github page]]

** Testing in haskell
*** DONE Add doctesting
    CLOSED: [2015-03-07 Sat 06:35]
*** DONE Add HUnit testing
    CLOSED: [2015-03-08 Sun 15:25] SCHEDULED: <2015-03-07 Sat>
*** TODO HSpec testing
    DEADLINE: <2015-03-22 Sun>
*** TODO learn testy
    DEADLINE: <2015-03-22 Sun>

** Rower of hanoi problem
*** DONE research the papaer "functional pearl: la tour d'hanoi" 
    CLOSED: [2015-03-15 Sun 20:21] DEADLINE: <2015-03-15 Sun> SCHEDULED: <2015-03-09 Mon>
*** TODO code and run the approach in the papaer "functional pearl: la tour d'hanoi" 
    DEADLINE: <2015-03-22 Sun>
** [[https://vimeo.com/6653485][Functional Pearl: La Tour D'Hanoi on vimeo]]


** DONE [[http://www.seas.upenn.edu/~cis194/fall14/lectures/01-intro.html][Week 1: Introduction to Haskell]]
   CLOSED: [2015-03-07 Sat 05:45] SCHEDULED: <2015-03-05 Thu>
   Haskell is lazy, functional language.
   Haskell is
   1. Functional
      1) functions are first-class
      2) evaluating expressions rather than executing instructions.
   2. Pure
      - Haskell expression are always referentially transparent
        * No mutations! Everything is immutable
        * No side effcts.
        * same input -> same output allways
      - Purity mean also
        * Equational reasoning and refactoring: In Haskell one can always "replace equals by equals", 
          just like you learned in algebra class.
        * Parallelism: Evaluating expressions in parallel is easy when they are guaranteed not to 
          affect one another.
        * Fewer headaches: Simply put, unrestricted effects and action-at-a-distance makes for programs
          that are hard to debug, maintain, and reason about.
   3. Lazy
       expressions are not evaluated until their results are actually needed
      * It is easy to define a new control structure just by defining a function.
      * It is possible to define and work with infinite data structures.
      * It enables a more compositional programming style (see wholemeal programming below).
      * One major downside, however, is that reasoning about time and space usage becomes much more complicated!
   4. Statically typed


** DONE Homework 1: CCard Number, Hanoi 
   CLOSED: [2015-03-08 Sun 20:37] SCHEDULED: <2015-03-06 Fri>
** DONE Week 2: Working with Lists
   CLOSED: [2015-03-10 Tue 22:34] SCHEDULED: <2015-03-09 Mon>
** DONE Homework 2: Scrabble 
   CLOSED: [2015-03-10 Tue 22:35] DEADLINE: <2015-03-11 Wed> SCHEDULED: <2015-03-09 Mon>
   [[file:d:/%3D%3DOnlineLearning/CIS194/reisenberg/homework/haskell/src/Hw02.hs::---%20Exercise%207.][file:../../CIS194/reisenberg/homework/haskell/src/Hw02.hs::--- Exercise 7.]]
** DONE Week 3: [[http://www.seas.upenn.edu/~cis194/fall14/lectures/03-ADTs.html][Algebraic data types]]  
   CLOSED: [2015-03-15 Sun 20:02] SCHEDULED: <2015-03-11 Wed>
   
   * Algebraic data types in general
     In general, an algebraic data type has one or more data constructors, and each data constructor 
     can have zero or more arguments.
   data AlgDataType = Constr1 Type11 Type12
                 | Constr2 Type21
                 | Constr3 Type31 Type32 Type33
                 | Constr4
   type and data constructor names must always start with a capital letter
   * Pattern Matching
     pattern-matching is about taking apart a value by finding out which constructor it was built with.
     This information can be used as the basis for deciding what to do—indeed, in Haskell, this is the 
     only way to make a decision.
   In general, the following grammar defines what can be used as a pattern:

   pat ::= _
     |  var
     |  var @ ( pat )
     |  ( Constructor pat1 pat2 ... patn )
     
   Note that literal values like 2 or 'c' can be thought of as constructors with no arguments. It is as if the 
   types Int and Char were defined like

   data Int  = 0 | 1 | -1 | 2 | -2 | ...
   data Char = 'a' | 'b' | 'c' | ...

   which means that we can pattern-match against literal values. (Of course, Int and Char are not actually 
   defined this way.)

   * Case expressions
     case exp of
       pat1 -> exp1
       pat2 -> exp2
       ...
   * First-class functions
   * Recursive data types
   Data types can be recursive, that is, defined in terms of themselves.
   data IntList = Empty | Cons Int IntList
   data Tree = Leaf Char
          | Node Tree Int Tree
          deriving Show
     

** DONE Homework 3: Log file parsing
   CLOSED: [2015-03-16 Mon 14:34] SCHEDULED: <2015-03-15 Sun>

** TODO [[http://www.seas.upenn.edu/~cis194/fall14/lectures/04-poly.html][Week 4 (18 September): Polymorphism]]
   SCHEDULED: <2015-03-16 Mon>
** TODO Homework 4: [[http://www.seas.upenn.edu/~cis194/fall14/hw/04-poly.pdf][Binary search trees]]
   SCHEDULED: <2015-03-16 Mon>


* [[http://www.seas.upenn.edu/~cis194/][cis194 Noam Zilberstein]]




